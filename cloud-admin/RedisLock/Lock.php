<?php

declare(strict_types=1);
/**
 * This file is part of Cloud-Admin.
 *
 * @link     https://www.cloud-admin.jayjay.cn
 * @document https://wiki.cloud-admin.jayjay.cn
 * @license  https://github.com/swow-cloud/swow-admin/blob/master/LICENSE
 */
namespace CloudAdmin\RedisLock;

use CloudAdmin\Interfaces\RedisLockInterface;
use Hyperf\Contract\ConfigInterface;
use Hyperf\Contract\StdoutLoggerInterface;
use Hyperf\Engine\Coroutine as SwowCo;
use Hyperf\Redis\Redis;
use Hyperf\Redis\RedisProxy;
use InvalidArgumentException;
use Psr\Container\ContainerExceptionInterface;
use Psr\Container\ContainerInterface;
use Psr\Container\NotFoundExceptionInterface;
use Ramsey\Uuid\Uuid;
use RedisException;
use Swow\Coroutine;
use Throwable;

use function CloudAdmin\Utils\formatThrowable;

class Lock implements RedisLockInterface
{
    /**
     * the unique id generated by the current coroutine.
     */
    protected string $value = '';

    private Redis|RedisProxy $redis;

    /**
     * the lock key.
     */
    private string $key = '';

    /**
     * the lock key's lifetime.
     */
    private int $ttl;

    private ContainerInterface $container;

    private StdoutLoggerInterface $logger;

    /**
     * redis lock config.
     */
    private array $config;

    /**
     * @throws ContainerExceptionInterface
     * @throws NotFoundExceptionInterface
     */
    public function __construct(ContainerInterface $container, Redis|RedisProxy $redis)
    {
        /* @noinspection UnusedConstructorDependenciesInspection */
        $this->container = $container;
        $this->redis = $redis;
        if (! $this->container->has(StdoutLoggerInterface::class)) {
            throw new InvalidArgumentException('StdoutLogger not found#');
        }
        if (! $config = $this->container->get(ConfigInterface::class)->get('redis_lock')) {
            throw new InvalidArgumentException('redis lock configuration not found#');
        }
        $this->config = $config;
        $this->logger = $this->container->get(StdoutLoggerInterface::class);
    }

    public function tryLock(string $key, int $ttl = 3): bool
    {
        $this->value = Uuid::uuid4()->toString();

        return $this->doLock($key, $ttl);
    }

    public function lock(string $key, int $ttl = 3, int $retries = 3, int $usleep = 10000): bool
    {
        $lock = false;
        $retryTimes = max($retries, 1);
        while ($retryTimes-- > 0) {
            $this->value = Uuid::uuid4()->toString();
            $lock = $this->doLock($key, $ttl);
            if ($lock) {
                break;
            }
            usleep($usleep);
            $this->logger->debug(
                sprintf('Try to acquire the lock again, the number of attempts: %s,Key: %s', $retryTimes, $key)
            );
        }

        return $lock;
    }

    public function unLock(): bool
    {
        $script = <<<'LUA'
            local key = KEYS[1]
            local value = ARGV[1]

            if (redis.call('exists', key) == 1 and redis.call('get', key) == value)
            then
                return redis.call('del', key)
            end

            return 0
LUA;

        return (bool) $this->execLuaScript($script, [$this->key, $this->value], 1);
    }

    public function lockTtl(): int
    {
        return $this->ttl;
    }

    /**
     * @throws Throwable
     */
    public function keepAlive(int $ttl = 3): bool
    {
        $script = <<<'LUA'
                -- get the remaining life time of the key
                local leftoverTtl = redis.call("TTL", KEYS[1]);

                -- never expired key
                if (leftoverTtl == -1) then
                    return -1;
                end;

                -- key with remaining time
                if (leftoverTtl ~= -2) then
                    return redis.call("EXPIRE", KEYS[1], ARGV[1]);
                end;

                -- key that does not exist
                return -2;
LUA;

        try {
            $eval = $this->execLuaScript($script, [$this->key, $ttl], 1);

            return $eval !== -2;
        } catch (Throwable $e) {
            $this->logger->error(formatThrowable($e));
            throw $e;
        }
    }

    /**
     * @throws Throwable
     */
    public function isAlive(): bool
    {
        if (! $this->key) {
            return false;
        }

        try {
            $eval = $this->redis->get($this->key);

            return $eval === $this->value;
        } catch (Throwable $e) {
            $this->logger->error(formatThrowable($e));
            throw $e;
        }
    }

    /**
     * @param mixed $key
     * @param mixed $ttl
     *
     * @throws Throwable
     */
    protected function doLock($key, $ttl): bool
    {
        $script = <<<'LUA'
            local key = KEYS[1]
            local value = ARGV[1]
            local ttl = ARGV[2]

            if (redis.call('setnx', key, value) == 1) then
                return redis.call('expire', key, ttl)
            elseif (redis.call('ttl', key) == -1) then
                return redis.call('expire', key, ttl)
            end

            return 0
LUA;
        $this->ttl = $ttl;
        $this->key = $key;

        try {
            $result = $this->execLuaScript($script, [$key, $this->value, $ttl], 1);
            if ($result) {
                $this->logger->debug(
                    sprintf(
                        'coroutine[%s] successfully hold lock[uuid:%s,key:%s], initialize the watchdog',
                        Coroutine::getCurrent()->getId(),
                        $this->value,
                        $this->key
                    )
                );
                SwowCo::create(function () {
                    $watchdog = \Hyperf\Support\make(WatchDog::class);
                    $watchdog->sentinel($this, $this->config['watchDogTime'] ?? 60);
                });
            }

            return (bool) $result;
        } catch (Throwable $exception) {
            $this->logger->error(formatThrowable($exception));
            throw $exception;
        }
    }

    /**
     * @throws Throwable
     * @throws RedisException
     */
    private function execLuaScript(string $script, array $args, int $number = 0): mixed
    {
        return $this->redis->evalSha($this->redis->script('load', $script), $args, $number);
    }
}
